Type
fecha= record
	   dia: 1..31;
	   mes: 1..12;
	   anio: 2000..2024;
	   end;
	   
venta1= record
	   cod: integer;
	   f: fecha;
	   cant: integer;
	   end;
	   
arbol1 = ^nodo1;
nodo1 = record
	    v: venta1;
	    HD: arbol1;
	    HI: arbol1;
	    end;
	    
venta2 = record
		cod: integer;
		cant: integer;
		end;

arbol2 = ^nodo2;
nodo2 = record
	    v: venta2;
	    HD: arbol2;
	    HI: arbol2;
	    end; 

v3 = record
		f: fecha;
	   cant: integer;
	   end;
	
lista = ^nodol;
nodol = record
	    dato: v3;
	    sig: lista;
	    end;

venta3 = record
	     cod: integer;
	     l: lista;
	     end;
	     
arbol3 = ^nodo3;
nodo3 = record
	    v:venta3;
	    HD: arbol3;
	    HI: arbol3;
	    end;
	    
procedure GenerarVenta (var v: venta1); 
begin;
	v.cod:= random(100);
	if (v.cod <> 0) then begin;
		v.f.dia:= 1 + random (31);
		v.f.mes:= 1 + random (12);
		v.f.anio:= 2000 + random (2024-2000+1);
		v.cant:= random (100);
	end;
end;

procedure GenerarA1 (var a:arbol1; v: venta1); 
begin;
//i. Generar y retornar un árbol binario de búsqueda de ventas ordenado por código de producto. Los códigos repetidos van a la derecha. 
	if (a = nil) then begin;
		new (a);
		a^.v:= v;
		a^.HD:= nil;
		a^.HI:= nil;
	end
	else if (v.cod < a^.v.cod) then GenerarA1 (a^.HI,v)
		 else GenerarA1 (a^.HD, v);
end;

procedure GenerarA2 (var a:arbol2; v: venta1); 
begin;
//ii. Generar y retornar otro árbol binario de búsqueda de productos vendidos ordenado por código de producto. Cada nodo del árbol debe contener el código de producto y
//la cantidad total de unidades vendidas. 
	if (a = nil) then begin;
		new (a);
		a^.v.cod:= v.cod;
		a^.v.cant:= v.cant;
		a^.HD:= nil;
		a^.HI:= nil;
	end
	else if (v.cod = a^.v.cod) then a^.v.cant:= a^.v.cant + v.cant
		 else if (v.cod < a^.v.cod) then GenerarA2 (a^.HI,v)
			  else GenerarA2 (a^.HD, v);
end;

procedure CargarLista (var l: lista; v: venta1); 
begin;
	if (l = nil) then begin;
		new (l);
		l^.dato.f:= v.f;
		l^.dato.cant:= v.cant;
		l^.sig:= nil;
	end
	else CargarLista (l^.sig, v);
end;
procedure GenerarA3 (a:arbol3; v: venta1); 
begin;
//iii. Generar y retornar otro árbol binario de búsqueda de productos vendidos ordenado por código de producto. Cada nodo del árbol debe contener el código de producto
//y la lista de las ventas realizadas del producto.
	if (a = nil) then begin;
		new (a);
		a^.v.cod:= v.cod;
		a^.v.l^.dato.f:= v.f;
		a^.v.l^.dato.cant:= v.cant;
		a^.v.l^.sig:= nil;
	end
	else if (v.cod = a^.v.cod) then CargarLista (a^.v.l^.sig, v)
		 else if (v.cod < a^.v.cod) then GenerarA3 (a^.HI,v)
			  else GenerarA3 (a^.HD, v);
end;

procedure Cargas (var a1: arbol1; var a2: arbol2; var a3: arbol3);
var v: venta1;
begin;
	GenerarVenta(v);
	if (v.cod <> 0) then begin;
		GenerarA1 (a1, v);
		GenerarA2 (a2, v);
		GenerarA3 (a3, v);
		Cargas (a1, a2, a3);
	end;
end;

{Nota: El módulo debe retornar TRES árboles.
b. Implemente un módulo que reciba el árbol generado en i. y una fecha y retorne la cantidad
total de productos vendidos en la fecha recibida.
c. Implemente un módulo que reciba el árbol generado en ii. y retorne el código de producto
con mayor cantidad total de unidades vendidas.
d. Implemente un módulo que reciba el árbol generado en iii. y retorne el código de producto
con mayor cantidad de ventas.
}
var
a1: arbol1;
a2: arbol2;
a3: arbol3;
Begin
	Cargas (a1,a2,a3);
end.
